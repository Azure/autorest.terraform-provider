@using AutoRest.Core
@using AutoRest.Terraform
@using System
@using System.Linq;
@inherits Template<SchemaGenerator>

func @(Model.FunctionName)() *schema.Resource {
	return &schema.Resource {
		Create: @Model.CreateFunctionName,
		Read:   @Model.ReadFunctionName,
		Delete: @Model.DeleteFunctionName,

		Schema: map[string]*schema.Schema {
@{
    var indent = 0;
    foreach (var field in Model.Fields)
    {
        if (field.IsFirstOccurrence)
        {
			@:@(new String('\t', indent))"@field.Name": {
            indent++;
			@:@(new String('\t', indent))Type: @field.Type,
            if (field.Type == "schema.TypeList")
            {
                foreach (var sub in field.Subtypes.Skip(1))
                {
			@:@(new String('\t', indent))Elem: &schema.Resource {
                    indent++;
			@:@(new String('\t', indent))Type: @sub,
                }
                if (field.TerminalType == "complex")
                {
			@:@(new String('\t', indent))Elem: &schema.Resource {
                    indent++;
			@:@(new String('\t', indent))Schema: map[string]*schema.Schema {
                    indent++;
                }
                else
                {
			@:@(new String('\t', indent))Elem: &schema.Schema {
			@:@(new String('\t', indent))  Type: @field.TerminalType,
			@:@(new String('\t', indent))},
                }
            }
        }
        else
        {
            if (field.Type == "schema.TypeList")
            {
                if (field.TerminalType == "complex")
                {
                    indent--;
			@:@(new String('\t', indent))},
                    indent--;
			@:@(new String('\t', indent))},
                }
                foreach (var sub in field.Subtypes.Skip(1))
                {
                    indent--;
			@:@(new String('\t', indent))},
                }
            }
            indent--;
			@:@(new String('\t', indent))},
        }
    }
}
		},
	}
}
@EmptyLine