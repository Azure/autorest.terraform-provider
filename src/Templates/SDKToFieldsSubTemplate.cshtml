@using AutoRest.Core
@using AutoRest.Terraform
@using AutoRest.Terraform.Templates
@using System.Collections.Generic
@using System.Diagnostics
@using System.Linq
@inherits TfProviderTemplateBase<(GoSDKTypedData Data, IEnumerable<GoSDKNonTerminalTypes> NonTermTypes, string Scope, Stack<IDictionary<string, string>> FieldDefs)>
@{
    Debug.Assert(Model.Data != null && Model.NonTermTypes != null && Model.Scope != null);

    var nestedCount = Model.NonTermTypes.Count();
    var assigner = Model.Scope + Model.Data.Name;
    if (string.IsNullOrEmpty(Model.Scope) && nestedCount > 0)
    {
        assigner += nestedCount;
    }

    if (!Model.NonTermTypes.Any())
    {
        if (Model.Data.GoType.Terminal != GoSDKTerminalTypes.Complex)
        {
@:@(Include<StoreFieldsDefSubTemplate, (TfProviderField, string, Stack<IDictionary<string, string>>)>((Model.Data.BackingField, assigner, Model.FieldDefs)))
        }
        else
        {
            foreach (var prop in Model.Data.Properties)
            {
@:@(Include<SDKToFieldsSubTemplate, (GoSDKTypedData, IEnumerable<GoSDKNonTerminalTypes>, string, Stack<IDictionary<string, string>>)>((prop, prop.GoType.Chain, assigner + ".", Model.FieldDefs)))
            }
        }
    }
    else
    {
        switch (Model.NonTermTypes.First())
        {
            case GoSDKNonTerminalTypes.Array:

                var childNestedCount = Model.NonTermTypes.Count() - 1;
                var fieldName = "r" + CodeNamer.GetAzureRmFieldLocalVarName(Model.Data.BackingField);
                if (nestedCount > 0)
                {
                    fieldName += nestedCount;
                }

@:@(Indentation)@(fieldName) := make([]interface{}?)

                var childAssigner = CodeNamer.GetAzureRmPropPathLocalVarName(Model.Data.PropertyPath.SplitPathStrings().Skip(1));
                if (childNestedCount > 0)
                {
                    childAssigner += childNestedCount;
                }

@:@(Indentation)for _, @(childAssigner) := range *@(assigner) {

                Indentation.Indent();
                Model.FieldDefs.Push(new Dictionary<string, string>());

@:@(Indentation)@(fieldName)___value := @(Model.Data.GoType.Terminal != GoSDKTerminalTypes.Complex ? childAssigner + ".(?)" : "make(map[string]interface{})")

                Model.FieldDefs.Peek().Add(Model.Data.BackingField.PropertyPath, fieldName + "___value");

@:@(Include<SDKToFieldsSubTemplate, (GoSDKTypedData, IEnumerable<GoSDKNonTerminalTypes>, string, Stack<IDictionary<string, string>>)>((Model.Data, Model.NonTermTypes.Skip(1), childAssigner + ".", Model.FieldDefs)))
@:@(Indentation)@(fieldName) = append(@(fieldName), @(fieldName)___value)

                Model.FieldDefs.Pop();
                Indentation.Outdent();

@:@(Indentation)}
@:@(Include<StoreFieldsDefSubTemplate, (TfProviderField, string, Stack<IDictionary<string, string>>)>((Model.Data.BackingField, fieldName, Model.FieldDefs)))

                break;
            case GoSDKNonTerminalTypes.StringMap:
@:@(Indentation)// MAP IS NOT IMPLEMENTED YET
                break;
        }
    }
}